import asyncio
import csv
import os
import traceback
import uuid

import fire
from aiogram import Bot, Dispatcher, F
from aiogram.client.default import DefaultBotProperties
from aiogram.enums import ParseMode
from aiogram.filters import Command
from aiogram.types import Message, InlineKeyboardButton, CallbackQuery, FSInputFile
from aiogram.utils.keyboard import InlineKeyboardBuilder
from rag import *
from database import Database
import prettytable as pt

Settings.embed_model = HuggingFaceEmbedding(
        model_name="./embedder"
    )
tokenizer, llm, retriever, reranker = None, None, None, None


class LlmBot:
    def __init__(
        self,
        bot_token: str,
        db_path: str,
        history_max_tokens: int,
        chunk_size: int,
    ):
        self.default_prompt = "–¢—ã ‚Äî –°–∞–π–≥–∞, —Ä—É—Å—Å–∫–æ—è–∑—ã—á–Ω—ã–π –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç. –¢—ã —Ä–∞–∑–≥–æ–≤–∞—Ä–∏–≤–∞–µ—à—å —Å –ª—é–¥—å–º–∏ –∏ –ø–æ–º–æ–≥–∞–µ—à—å –∏–º."
        assert self.default_prompt

        # –ü–∞—Ä–∞–º–µ—Ç—Ä—ã
        self.history_max_tokens = history_max_tokens
        self.chunk_size = chunk_size

        # –ë–∞–∑–∞
        self.db = Database(db_path)

        # –ö–ª–∞–≤–∏–∞—Ç—É—Ä—ã
        self.start_kb = InlineKeyboardBuilder()
        self.start_kb.add(InlineKeyboardButton(text='–£–∑–Ω–∞—Ç—å –∫–æ–º–∞–Ω–¥—ã', callback_data='commands'))
        self.likes_kb = InlineKeyboardBuilder()
        self.likes_kb.add(InlineKeyboardButton(
            text="üëç",
            callback_data="feedback:like"
        ))
        self.likes_kb.add(InlineKeyboardButton(
            text="üëé",
            callback_data="feedback:dislike"
        ))

        # –ë–æ—Ç
        self.bot = Bot(token=bot_token, default=DefaultBotProperties(parse_mode=ParseMode.MARKDOWN))
        self.dp = Dispatcher()

        self.dp.message.register(self.start, Command("start"))
        self.dp.message.register(self.reset, Command("reset_history"))
        self.dp.message.register(self.history, Command("history"))
        self.dp.message.register(self.about_team, Command("team"))
        self.dp.message.register(self.set_system, Command("set_system"))
        self.dp.message.register(self.get_system, Command("get_system"))
        self.dp.message.register(self.reset_system, Command("reset_system"))
        self.dp.message.register(self.add_knowledge, Command("add_knowledge"))
        self.dp.message.register(self.generate)

        self.dp.callback_query.register(self.save_feedback, F.data.startswith("feedback:"))
        self.dp.callback_query.register(self.show_commands, F.data.startswith('commands'))


    async def start_polling(self):
        await self.dp.start_polling(self.bot)

    async def start(self, message: Message):
        chat_id = message.chat.id
        self.db.create_conv_id(chat_id)
        markup = self.start_kb.as_markup()
        await message.reply("–ü—Ä–∏–≤–µ—Ç! –Ø –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç, –æ—Ç–≤–µ—á–∞—é—â–∏–π –Ω–∞ –≤–æ–ø—Ä–æ—Å—ã –Ω–∞ —Ç–µ–º—ã –ø–æ –ø–ª–∞—Ç—Ñ–æ—Ä–º–µ 1–°: –ü—Ä–µ–¥–ø—Ä–∏—è—Ç–∏–µ. –î–æ—Å—Ç—É–ø–Ω–æ 2 –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ —É–∑–Ω–∞—Ç—å —Å–ø–∏—Å–æ–∫ –∫–æ–º–∞–Ω–¥\n   - –ö–Ω–æ–ø–∫–∞ '–£–∑–Ω–∞—Ç—å –∫–æ–º–∞–Ω–¥—ã'\n   - –ö–Ω–æ–ø–∫–∞ 'Menu', —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–Ω–∞—è —Å–ª–µ–≤–∞ –æ—Ç —Å—Ç—Ä–æ–∫–∏ –∑–∞–ø—Ä–æ—Å–∞", reply_markup=markup)

    async def set_system(self, message: Message):
        chat_id = message.chat.id
        text = message.text.replace("/setsystem", "").strip()
        self.db.set_system_prompt(chat_id, text)
        self.db.create_conv_id(chat_id)
        await message.reply(f"–ù–æ–≤—ã–π —Å–∏—Å—Ç–µ–º–Ω—ã–π –ø—Ä–æ–º–ø—Ç –∑–∞–¥–∞–Ω:\n\n{text}")

    async def get_system(self, message: Message):
        chat_id = message.chat.id
        prompt = self.db.get_system_prompt(chat_id, self.default_prompt)
        if prompt.strip():
            await message.reply(prompt)
        else:
            await message.reply("–°–∏—Å—Ç–µ–º–Ω—ã–π –ø—Ä–æ–º–ø—Ç –ø—É—Å—Ç")

    async def reset_system(self, message: Message):
        chat_id = message.chat.id
        self.db.set_system_prompt(chat_id, self.default_prompt)
        self.db.create_conv_id(chat_id)
        await message.reply("–°–∏—Å—Ç–µ–º–Ω—ã–π –ø—Ä–æ–º–ø—Ç —Å–±—Ä–æ—à–µ–Ω!")

    async def reset(self, message: Message):
        chat_id = message.chat.id
        self.db.create_conv_id(chat_id)
        await message.reply("–ò—Å—Ç–æ—Ä–∏—è —Å–æ–æ–±—â–µ–Ω–∏–π —Å–±—Ä–æ—à–µ–Ω–∞!")

    async def history(self, message: Message):
        chat_id = message.chat.id
        conv_id = self.db.get_current_conv_id(chat_id)
        history = self.db.fetch_conversation(conv_id, include_meta=True)
        feedback = {'like': "–û—Ç–≤–µ—Ç –ø–æ–Ω—Ä–∞–≤–∏–ª—Å—è", 'dislike': "–û—Ç–≤–µ—Ç –Ω–µ –ø–æ–Ω—Ä–∞–≤–∏–ª—Å—è"}
        user_question = ''
        bot_answer = ''
        for i, m in enumerate(history[-10:]):
            if not isinstance(m["text"], str):
                m["text"] = "–ù–µ —Ç–µ–∫—Å—Ç"
            if i % 2 == 0:
                user_question = m['text']
            else:
                bot_answer = m['text']
                text_feedback = self.db.get_current_feedback(m['message_id'])
                await self.bot.send_message(text=f'–ó–∞–ø—Ä–æ—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {user_question}\n------------------------------------------------------------------------------------\n–û—Ç–≤–µ—Ç –±–æ—Ç–∞: {bot_answer}\n------------------------------------------------------------------------------------\n–û—Ü–µ–Ω–∫–∞: {feedback[text_feedback]}', chat_id=chat_id)

    async def about_team(self, message: Message):
        photo_team = FSInputFile("photo_team.png")
        await self.bot.send_photo(photo=photo_team, chat_id=message.chat.id)
    
    # –î–æ–ø–∏—Å–∞—Ç—å!
    async def add_knowledge(self, message: Message):
        with open('rag_app\dataset_eda.csv', mode='a') as file:
            writer = csv.writer(file)
            writer.writerow(['question', 'answer'])

    def get_user_name(self, message: Message):
        return message.from_user.full_name if message.from_user.full_name else message.from_user.username

    async def generate(self, message: Message):
        user_id = message.from_user.id
        user_name = self.get_user_name(message)
        chat_id = user_id
        conv_id = self.db.get_current_conv_id(chat_id)
        system_prompt = self.db.get_system_prompt(chat_id, self.default_prompt)

        content = await self._build_content(message)
        if not isinstance(content, str):
            await message.answer("–í—ã–±—Ä–∞–Ω–Ω–∞—è –º–æ–¥–µ–ª—å –Ω–µ –º–æ–∂–µ—Ç –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –≤–∞—à–µ —Å–æ–æ–±—â–µ–Ω–∏–µ")
            return
        if content is None:
            await message.answer("–¢–∞–∫–æ–π —Ç–∏–ø —Å–æ–æ–±—â–µ–Ω–∏–π (–µ—â—ë) –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è")
            return

        self.db.save_user_message(content, conv_id=conv_id, user_id=user_id, user_name=user_name)
        placeholder = await message.answer("üí¨")

        try:
            answer = await self.query_api(
                user_content=content,
                system_prompt=system_prompt
            )
            chunk_size = self.chunk_size
            answer_parts = [answer[i:i + chunk_size] for i in range(0, len(answer), chunk_size)]
            markup = self.likes_kb.as_markup()
            new_message = await placeholder.edit_text(answer_parts[0], parse_mode=None, reply_markup=markup)

            self.db.save_assistant_message(
                content=answer,
                conv_id=conv_id,
                message_id=new_message.message_id,
                system_prompt=system_prompt
            )

        except Exception:
            traceback.print_exc()
            await placeholder.edit_text("–ß—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫")


    async def save_feedback(self, callback: CallbackQuery):
        user_id = callback.from_user.id
        message_id = callback.message.message_id
        feedback = callback.data.split(":")[1]
        self.db.save_feedback(feedback, user_id=user_id, message_id=message_id)
        await self.bot.edit_message_reply_markup(
            chat_id=callback.message.chat.id,
            message_id=message_id,
            reply_markup=None
        )

    async def show_commands(self, callback: CallbackQuery):
        table = pt.PrettyTable(['–ö–æ–º–∞–Ω–¥–∞', '–û–ø–∏—Å–∞–Ω–∏–µ'])
        data = [
            ('start', '–ü—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ'),
            ('history', '–ü—Ä–æ—Å–º–æ—Ç—Ä–µ—Ç—å –∏—Å—Ç–æ—Ä–∏—é'),
            ('reset_history', '–û—á–∏—Å—Ç–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—é'),
            ('set_system', '–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –Ω–æ–≤—ã–π —Å–∏—Å—Ç–µ–º–Ω—ã–π –ø—Ä–æ–º–ø—Ç'),
            ('get_system', '–ü—Ä–æ—Å–º–æ—Ç—Ä–µ—Ç—å —Ç–µ–∫—É—â–∏–π —Å–∏—Å—Ç–µ–º–Ω—ã–π –ø—Ä–æ–º–ø—Ç'),
            ('reset_system', '–°–±—Ä–æ—Å–∏—Ç—å —Å–∏—Å—Ç–µ–º–Ω—ã–π –ø—Ä–æ–º–ø—Ç –¥–æ –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é'),
            ('team', '–£–∑–Ω–∞—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∫–æ–º–∞–Ω–¥–µ —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤'),
        ]
        for command, description in data:
            table.add_row([command, description])
        await callback.message.edit_text(
            f'–í –±–æ—Ç–µ –¥–æ—Å—Ç—É–ø–Ω—ã —Å–ª–µ–¥—É—é—â–∏–µ –∫–æ–º–∞–Ω–¥—ã:\n```python\n{table}```',
            parse_mode='MarkdownV2'
        )
    

    @staticmethod
    def _merge_messages(messages):
        new_messages = []
        prev_role = None
        for m in messages:
            content = m["text"]
            role = m["role"]
            if content is None:
                continue
            if role == prev_role:
                is_current_str = isinstance(content, str)
                is_prev_str = isinstance(new_messages[-1]["text"], str)
                if is_current_str and is_prev_str:
                    new_messages[-1]["text"] += "\n\n" + content
                    continue
            prev_role = role
            new_messages.append(m)
        return new_messages

    def _crop_content(self, content):
        if isinstance(content, str):
            return content.replace("\n", " ")[:40]
        return "Not text"

    async def query_api(self, user_content, system_prompt: str) -> tuple:
        names, pages, chunks, relevant_score = top_k_rerank(user_content, retriever, reranker)
        if relevant_score >= 0.52:
            answer = vllm_infer(tokenizer, llm, chunks, user_content, system_prompt)
            if answer[0] == '–Ø –Ω–µ –º–æ–≥—É –æ—Ç–≤–µ—Ç–∏—Ç—å –Ω–∞ –≤–∞—à –≤–æ–ø—Ä–æ—Å.':
                return answer[0]
            else:
                generated_text = '''{llm_gen}\n===================================\n–ò—Å—Ç–æ—á–Ω–∏–∫–∏ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏:\n–î–æ–∫—É–º–µ–Ω—Ç {doc_name}, {page_number}'''
                formatted_answer = generated_text.format(
                    llm_gen=answer[0],
                    doc_name=names[0], page_number=pages[0]
                )
                return formatted_answer
        return '–î–∞–Ω–Ω—ã–π –≤–æ–ø—Ä–æ—Å –≤—ã—Ö–æ–¥–∏—Ç –∑–∞ —Ä–∞–º–∫–∏ –∫–æ–º–ø–µ—Ç–µ–Ω—Ü–∏–π –±–æ—Ç–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–µ—Ä–µ—Ñ–æ—Ä–º—É–ª–∏—Ä—É–π—Ç–µ –≤–æ–ø—Ä–æ—Å –∏–ª–∏ –ø–æ–ø—Ä–æ—Å–∏—Ç–µ –≤—ã–∑–≤–∞—Ç—å —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∞.'

    
    async def _get_text_from_audio(audio):
        pass

    async def _build_content(self, message: Message):
        content_type = message.content_type
        if content_type == "text":
            text = message.text
            return text
        elif content_type == 'audio':
            voice = message.voice.get_file()
            file_name = uuid.uuid4()
            os.makedirs('voices', exist_ok=True)
            await self.bot.download_file(file_path=voice.file_path, destination=os.path.join('voices', file_name))
            text = self._get_text_from_audio(os.path.join('voices', file_name))
            os.remove(os.path.join('voices', file_name))
            return text
        return None


def main(
    bot_token: str,
    db_path: str,
    history_max_tokens: int = 4500,
    chunk_size: int = 2000,
) -> None:
    global tokenizer, llm, retriever, reranker
    tokenizer, llm, retriever, reranker = start_rag()
    bot = LlmBot(
        bot_token=bot_token,
        db_path=db_path,
        history_max_tokens=history_max_tokens,
        chunk_size=chunk_size,
    )
    asyncio.run(bot.start_polling())


if __name__ == "__main__":
    fire.Fire(main)
